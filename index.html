<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Scanner de Cor Autônomo</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; font-family: Arial, sans-serif; overflow: hidden; }
        video { width: 100vw; height: 100vh; object-fit: cover; }
        .overlay-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; align-items: center; z-index: 10; }
        .status-bar { background-color: rgba(0,0,0,0.7); color: white; padding: 10px 15px; margin-top: 15px; border-radius: 8px; font-size: 16px; text-align: center; }
        .action-button { background-color: #4CAF50; color: white; padding: 15px 25px; margin-bottom: 25px; border: none; border-radius: 8px; font-size: 18px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .action-button:active { background-color: #45a049; }
        .crosshair { position: absolute; top: 50%; left: 50%; width: 30px; height: 30px; border: 2px solid yellow; transform: translate(-50%, -50%); mix-blend-mode: difference; }
        canvas { display: none; } /* Canvas oculto para processamento */
    </style>
</head>
<body>
    <video playsinline autoplay muted></video>
    <div class="crosshair"></div>
    <canvas></canvas>

    <div class="overlay-container">
        <div id="status" class="status-bar">Iniciando câmera...</div>
        <button id="voiceButton" class="action-button">Falar Cor Alvo</button>
    </div>

    <script>
        const video = document.querySelector('video');
        const canvas = document.querySelector('canvas');
        const context = canvas.getContext('2d', { willReadFrequently: true });
        const statusDiv = document.getElementById('status');
        const voiceButton = document.getElementById('voiceButton');

        let targetColor = "";
        let lastColorSent = ''; // Para a lógica de "só envia se mudar" (que aqui é só para o beep)
        let lastBeepTime = 0;   // Para controlar a frequência do beep
        const beepInterval = 2000; // Intervalo mínimo entre beeps em milissegundos (2 segundos)

        // --- Lógica de Áudio para o Beep ---
        let audioContext;
        function setupAudio() {
            if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        function playBeep() {
            if (!audioContext) return; // Não pode tocar se o contexto não foi criado
            const currentTime = audioContext.currentTime;
            if (currentTime < lastBeepTime + (beepInterval / 1000)) {
                return; // Ignora se o último beep foi muito recente
            }
            lastBeepTime = currentTime;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(660, currentTime); // Frequência do beep
            gainNode.gain.setValueAtTime(0.1, currentTime); // Volume baixo
            gainNode.gain.exponentialRampToValueAtTime(0.00001, currentTime + 0.3); // Fade out
            oscillator.start(currentTime);
            oscillator.stop(currentTime + 0.3); // Duração do beep
        }
        // Tenta inicializar o AudioContext após uma interação do usuário
        voiceButton.addEventListener('click', () => {
            if (!audioContext) {
                setupAudio();
            }
            handleTargetColorVoiceInput();
        });


        // --- Lógica de Conversão de Cor ---
        function rgbToHsv(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
            let d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max === min) { h = 0; } else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s, v];
        }
        function rgbToColorName(r, g, b) {
            if (r < 35 && g < 35 && b < 35) return "preto";
            if (r > 220 && g > 220 && b > 220) return "branco";
            if (Math.abs(r - g) < 25 && Math.abs(g - b) < 25 && Math.abs(r - b) < 25 && (r > 35 && r < 220)) return "cinza";
            let hsv = rgbToHsv(r, g, b);
            let h = hsv[0], s = hsv[1], v = hsv[2];
            if (s < 0.20 && v > 0.5 && (h > 20 && h < 60) ) return "bege"; // Ajustado para bege
            if (h < 15 || h >= 345) return "vermelho";
            if (h >= 15 && h < 45)  return "laranja";
            if (h >= 45 && h < 70)  return "amarelo";
            if (h >= 70 && h < 160) return "verde";
            if (h >= 160 && h < 260) return "azul";
            if (h >= 260 && h < 300) return "roxo";
            if (h >= 300 && h < 345) return "rosa";
            return "";
        }

        // --- Lógica da Câmera ---
        async function startCamera() {
            statusDiv.innerHTML = 'Tentando acessar a câmera traseira...';
            const constraints = { video: { facingMode: 'environment', width: { ideal: 640 }, height: {ideal: 480} } };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    statusDiv.innerHTML = 'Câmera pronta. Clique em "Falar Cor Alvo".';
                    requestAnimationFrame(detectColorLoop);
                };
            } catch (err) {
                statusDiv.innerHTML = 'Erro ao iniciar câmera: ' + err.message;
                console.error("Erro ao iniciar a câmera: ", err);
            }
        }

        // --- Lógica de Detecção de Cor ---
        function detectColorLoop() {
            if (!video.srcObject || video.paused || video.ended || video.videoWidth === 0) {
                requestAnimationFrame(detectColorLoop); return;
            }
            try {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const pixelData = context.getImageData(Math.floor(canvas.width / 2), Math.floor(canvas.height / 2), 1, 1).data;
                const detectedColorName = rgbToColorName(pixelData[0], pixelData[1], pixelData[2]);

                if (detectedColorName && targetColor && detectedColorName.length > 0 && detectedColorName === targetColor) {
                    if (detectedColorName !== lastColorSent) { // Só atualiza o status se a cor alvo detectada for "nova"
                         statusDiv.innerHTML = "Cor Encontrada: <b style='color:" + detectedColorName + "; text-shadow: 0 0 2px black;'>" + detectedColorName.toUpperCase() + "</b>!";
                         lastColorSent = detectedColorName; // Atualiza para evitar spam de status
                    }
                    playBeep(); // Toca o beep se a cor alvo for detectada
                } else if (detectedColorName && detectedColorName.length > 0 && detectedColorName !== lastColorSent && targetColor) {
                    // statusDiv.innerHTML = "Vendo: " + detectedColorName + ". Procurando por: " + targetColor;
                    // lastColorSent = detectedColorName;
                } else if (!targetColor){
                    // statusDiv.innerHTML = "Defina uma cor alvo.";
                }


            } catch (e) {
                console.error("Erro no loop de detecção:", e);
            }
            requestAnimationFrame(detectColorLoop);
        }

        // --- Lógica de Reconhecimento de Voz ---
        function handleTargetColorVoiceInput() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                statusDiv.innerHTML = "Erro: Reconhecimento de voz não suportado neste navegador.";
                return;
            }
            const recognition = new SpeechRecognition();
            recognition.lang = 'pt-BR';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;
            recognition.start();
            statusDiv.innerHTML = "Ouvindo...";

            recognition.onresult = (event) => {
                let spokenText = event.results[0][0].transcript.toLowerCase().trim();
                // Pequena correção para cores compostas que podem ser faladas juntas
                if (spokenText.includes("azul claro")) spokenText = "azul"; // Exemplo
                if (spokenText.includes("verde claro")) spokenText = "verde"; // Exemplo

                targetColor = spokenText;
                lastColorSent = ""; // Reseta para que o status da cor possa ser mostrado de novo
                statusDiv.innerHTML = "Procurando por: <b>" + targetColor + "</b>";
            };
            recognition.onerror = (event) => {
                statusDiv.innerHTML = "Erro na voz: " + event.error;
                if (event.error === 'no-speech') {
                    statusDiv.innerHTML = "Nenhuma fala detectada. Tente de novo.";
                }
            };
            recognition.onspeechend = () => {
                recognition.stop();
            };
        }
        
        // Inicia a câmera assim que a página carrega
        startCamera();
    </script>
</body>
</html>
