<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leitor de Cor em Tempo Real</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; }
        video { width: 100vw; height: 100vh; object-fit: cover; }
        .crosshair { position: absolute; top: 50%; left: 50%; width: 30px; height: 30px; border: 2px solid white; transform: translate(-50%, -50%); mix-blend-mode: difference; }
    </style>
</head>
<body>
    <video playsinline autoplay muted></video> <div class="crosshair"></div>
    <canvas style="display: none;"></canvas>

    <script>
        const video = document.querySelector('video');
        const canvas = document.querySelector('canvas');
        const context = canvas.getContext('2d', { willReadFrequently: true });
        let lastColorSent = '';
        let cameraInitialized = false; // Flag para controlar a inicialização

        // Função auxiliar para converter RGB para HSV (Matiz, Saturação, Valor)
        function rgbToHsv(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, v = max;
            let d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max === min) {
                h = 0; // achromatic
            } else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s, v];
        }

        // Função para converter RGB para um nome de cor mais completo
        function rgbToColorName(r, g, b) {
            // Preto, Branco, Cinza
            if (r < 35 && g < 35 && b < 35) return "preto";
            if (r > 220 && g > 220 && b > 220) return "branco";
            // Para cinza, verificamos se R, G e B estão próximos e não são muito escuros ou muito claros
            if (Math.abs(r - g) < 25 && Math.abs(g - b) < 25 && Math.abs(r - b) < 25 && (r > 35 && r < 220) ) return "cinza";

            let hsv = rgbToHsv(r, g, b);
            let h = hsv[0]; // Matiz (0-360)
            let s = hsv[1]; // Saturação (0-1)
            let v = hsv[2]; // Valor/Brilho (0-1)

            if (s < 0.20 && v > 0.5) return "bege"; // Saturação baixa, brilho não muito escuro = bege/creme

            if (h < 15 || h >= 345) return "vermelho";  // Vermelho
            if (h >= 15 && h < 45)  return "laranja"; // Laranja
            if (h >= 45 && h < 70)  return "amarelo"; // Amarelo
            if (h >= 70 && h < 160) return "verde";   // Verde
            if (h >= 160 && h < 260) return "azul";    // Azul
            if (h >= 260 && h < 300) return "roxo";    // Roxo
            if (h >= 300 && h < 345) {                // Rosa / Magenta
                if (v > 0.6 && s > 0.3) return "rosa"; // Magenta/Rosa mais vívido
                return "rosa"; // Ou um rosa mais genérico
            }
            
            return ""; // Retorna vazio se não for uma cor clara da lista
        }

        async function startCamera() {
            if (cameraInitialized) return; // Previne múltiplas inicializações
            cameraInitialized = true;
            console.log("JS: startCamera() chamada pelo Thunkable.");

            const constraints = { video: { facingMode: 'environment' } };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    if (window.ReactNativeWebView) window.ReactNativeWebView.postMessage("camera_pronta");
                    console.log("JS: Câmera pronta e mensagem enviada.");
                    requestAnimationFrame(detectColorLoop);
                };
            } catch (err) {
                console.error("JS: Erro ao iniciar a câmera: ", err);
                if (window.ReactNativeWebView) window.ReactNativeWebView.postMessage("error:camera_falhou - " + err.message);
            }
        }

        function detectColorLoop() {
            if (!video.srcObject || video.paused || video.ended || video.videoWidth === 0) {
                requestAnimationFrame(detectColorLoop); // Continua tentando se o vídeo não estiver pronto
                return;
            }
            try {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const pixelData = context.getImageData(Math.floor(canvas.width / 2), Math.floor(canvas.height / 2), 1, 1).data;
                const colorName = rgbToColorName(pixelData[0], pixelData[1], pixelData[2]);

                if (colorName && colorName.length > 0 && colorName !== lastColorSent) {
                    lastColorSent = colorName;
                    if (window.ReactNativeWebView) {
                        window.ReactNativeWebView.postMessage("color:" + colorName);
                    }
                }
            } catch (e) {
                console.error("JS: Erro no detectColorLoop:", e);
            }
            requestAnimationFrame(detectColorLoop);
        }

        // EventListener para comandos do Thunkable
        window.addEventListener("message", (event) => {
            console.log("JS: Mensagem recebida do Thunkable: " + event.data);
            if (event.data === 'command:initializeCamera') {
                startCamera(); // Thunkable agora comanda o início da câmera
            }
        });

        // A linha "startCamera();" foi REMOVIDA daqui. A câmera só inicia com o comando do Thunkable.
    </script>
</body>
</html>
