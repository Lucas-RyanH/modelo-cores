<!DOCTYPE html>
<html>
<head>
    </head>
<body>
    <script type="text/javascript">
        const URL = "./"; // Certifique-se que seus arquivos model.json e metadata.json estão na mesma pasta do index.html ou ajuste o caminho
        let model, webcam;
        let jsAppTargetColor = ""; // Renomeei para evitar confusão com a variável global targetColor se houver
        let jsLastDetectedForBeep = ""; // Renomeei para clareza

        // Thunkable chama esta função para definir a cor alvo
        // Esta função já está no seu código e está boa!
        function setTargetColorFunction(color) { // Renomeei para evitar conflito com nome de variável global, se houver
            jsAppTargetColor = color.toLowerCase();
            jsLastDetectedForBeep = ""; // Reseta para permitir novo beep
            console.log("JS: Cor alvo definida para: " + jsAppTargetColor);
        }

        // !!!!! ADICIONE ESTE BLOCO !!!!!
        // Ouvinte para mensagens vindas do Thunkable
        window.addEventListener('message', function(event) {
            const messageFromThunkable = event.data;
            console.log("JS: Mensagem recebida do Thunkable: " + messageFromThunkable);

            if (typeof messageFromThunkable === 'string' && messageFromThunkable.startsWith('setTargetColor:')) {
                const colorName = messageFromThunkable.substring('setTargetColor:'.length);
                setTargetColorFunction(colorName); // Chama a função para definir a cor
            }
        });
        // !!!!! FIM DO BLOCO A ADICIONAR !!!!!

        async function init() {
            const startButton = document.getElementById('startButton');
            startButton.innerHTML = "Carregando...";
            startButton.disabled = true;

            try {
                const modelURL = URL + "model.json";
                const metadataURL = URL + "metadata.json";
                [model, webcam] = await Promise.all([
                    tmImage.load(modelURL, metadataURL),
                    new tmImage.Webcam(400, 400, true)
                ]);

                await webcam.setup();
                await webcam.play();
                document.getElementById('webcam-container').appendChild(webcam.canvas);
                
                document.getElementById('mainContainer').style.display = 'none';

                if (window.ReactNativeWebView) {
                    window.ReactNativeWebView.postMessage("camera_pronta");
                    console.log("JS: Enviado 'camera_pronta'");
                }

                window.requestAnimationFrame(loop);
            } catch (e) {
                console.error("JS: Erro no init:", e);
                startButton.innerHTML = "Erro ao iniciar. Tente novamente.";
                startButton.disabled = false;
            }
        }

        async function loop() {
            if (webcam && webcam.canvas && webcam.canvas.readyState !== 4) { // Adicionado webcam.canvas.readyState !== 4 para verificar se o canvas está pronto
                webcam.update();
                await predict();
                window.requestAnimationFrame(loop);
            } else if (webcam && webcam.canvas && webcam.canvas.readyState === 4) {
                console.log("JS: Canvas não está pronto, tentando novamente no próximo frame.");
                window.requestAnimationFrame(loop); // Tenta novamente se não estiver pronto
            }
        }

        async function predict() {
            // Renomeado para jsAppTargetColor e jsLastDetectedForBeep para consistência
            if (!model || !webcam || !webcam.canvas || !jsAppTargetColor) { // Adicionado !webcam e !webcam.canvas
                 //console.log("JS: Predict pulado: modelo, webcam, canvas ou cor alvo não prontos.");
                 return;
            }
            const prediction = await model.predict(webcam.canvas);
            let highestProbability = 0;
            let predictedClass = "";

            for (let i = 0; i < prediction.length; i++) {
                if (prediction[i].probability > highestProbability) {
                    highestProbability = prediction[i].probability;
                    predictedClass = prediction[i].className;
                }
            }

            if (predictedClass && highestProbability > 0.80) { // Limiar de confiança
                const currentDetected = predictedClass.toLowerCase();
                if (currentDetected === jsAppTargetColor && jsLastDetectedForBeep !== jsAppTargetColor) {
                    if (window.ReactNativeWebView) {
                        window.ReactNativeWebView.postMessage("beep");
                        console.log("JS: Enviado 'beep' para cor: " + currentDetected);
                    }
                }
                jsLastDetectedForBeep = currentDetected;
            }
        }
    </script>
</body>
</html>
